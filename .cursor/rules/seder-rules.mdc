---
alwaysApply: true
---

You are an expert developer building Seder, a full-stack SaaS platform to help small-medium businesses manage inventory, employees, and finances more efficiently.

üß± Tech Stack

Backend: Node.js, Express, PostgreSQL (via Prisma), JWT, bcrypt, dotenv

Frontend: React (via Next.js), Tailwind CSS

UI Components: Shadcn UI, Lucide Icons, Radix UI

Validation & Security: Zod, JWT with HTTP-only cookies, next-safe-action

Optional Tools: Supabase (DB hosting), OpenAI SDK, Vercel (frontend hosting)

üîë Key Principles

Build scalable, modular, and maintainable code

Organize by feature/domain (e.g., features/auth, features/inventory)

Prefer reusability and componentization (atomic design)

Functional, declarative code ‚Äî no class-based logic

Use RORO (Receive Object, Return Object) in services and utilities

Use clear variable names: isAdmin, hasPermission, shouldDisplay

Use lowercase-dash naming for folders (e.g., components/login-form)

Named exports only (no default exports)

üî† TypeScript & Structure

All code must be in TypeScript

Use interfaces for public contracts and types for internal helpers

File order:

Main export

Subcomponents

Helpers

Static content

Types

Avoid semicolons and extra braces

Prefer early return and one-liner logic where possible

‚ö†Ô∏è Error Handling & Validation

Use guard clauses for errors and edge cases

Keep "happy path" at the bottom of the function

Validate inputs with Zod

Throw custom errors (AuthError, ValidationError) as needed

Return clean, user-friendly error messages

Never expose internal logic to client

Log errors on the server only

üîê Authentication & Sessions

Auth system:

Email/password

bcrypt for hashing

JWT for session tokens (stored in HTTP-only cookies)

Store active sessions in a Session table

Middleware for protected routes (e.g., /dashboard)

Use next-safe-action for secure server actions with input validation

‚öôÔ∏è React & Next.js

Use React Server Components where possible

All components are functional (use function syntax)

Structure UI by domain (features/inventory, features/shift, etc.)

Use Tailwind for responsive styling and layout

Wrap async components with <Suspense fallback={...}>

Use next/image for all images (optimize with WebP, lazy loading)

Avoid useEffect unless absolutely necessary

üì¶ API & Server Logic

Backend lives in /server

Use Express routes (/api/) with separated controllers/services

Prisma for DB access (lib/db.ts)

Store logic in services (services/auth/login.ts, services/inventory/getAll.ts)

Use .env for DB credentials, JWT secrets, API keys

üóÉÔ∏è Database & Prisma

Use PostgreSQL (hosted on Supabase or Neon)

Prisma schema lives in prisma/schema.prisma

Key tables:

User, Session, InventoryItem, Order, Supplier, Shift, Notification, Transaction

Prefer enums for status fields (e.g., OrderStatus, StockLevel)

Seed development data in prisma/seed.ts

üé® UI & Components

Use Shadcn UI + Radix UI for accessibility and style

Style components using Tailwind + Class Variance Authority (CVA)

Design with atomic principles (Button, Input, etc.)

Split large components to *-view.tsx and *-logic.ts

Maintain layout hierarchy: heading > content > actions

Fully responsive design ‚Äî mobile-first approach

üß† AI Features (Phase 2+)

Use OpenAI SDK for business recommendations and summaries

Stream data using Vercel AI SDK if needed

Always sanitize inputs

Handle errors gracefully and use fallback messages

Save chat/query history to database or Vercel KV

Store AI keys and endpoints securely in .env

üß™ Testing

Unit tests: Jest for services, validators, helpers

E2E tests: Playwright for flows like login, inventory update

Tests should use local Supabase or test-specific DB

Cover edge cases, unhappy paths, validation

‚ôø Accessibility & Performance

Ensure keyboard access to all components

Use ARIA labels and roles appropriately

Tailwind color contrast must follow WCAG

Optimize performance: lazy loading, suspense, caching

Monitor Core Web Vitals (LCP, CLS, FID)

üìö Documentation & DX

Use JSDoc for all utilities and service functions

Keep README.md updated with:

Tech stack and dependencies

Local dev setup

Auth flow

Deployment guide

Document all Prisma schemas and relationships

Add comments for AI-related logic and rate limits

You are an expert developer building Seder, a full-stack SaaS platform to help small-medium businesses manage inventory, employees, and finances more efficiently.

üß± Tech Stack

Backend: Node.js, Express, PostgreSQL (via Prisma), JWT, bcrypt, dotenv

Frontend: React (via Next.js), Tailwind CSS

UI Components: Shadcn UI, Lucide Icons, Radix UI

Validation & Security: Zod, JWT with HTTP-only cookies, next-safe-action

Optional Tools: Supabase (DB hosting), OpenAI SDK, Vercel (frontend hosting)

üîë Key Principles

Build scalable, modular, and maintainable code

Organize by feature/domain (e.g., features/auth, features/inventory)

Prefer reusability and componentization (atomic design)

Functional, declarative code ‚Äî no class-based logic

Use RORO (Receive Object, Return Object) in services and utilities

Use clear variable names: isAdmin, hasPermission, shouldDisplay

Use lowercase-dash naming for folders (e.g., components/login-form)

Named exports only (no default exports)

üî† TypeScript & Structure

All code must be in TypeScript

Use interfaces for public contracts and types for internal helpers

File order:

Main export

Subcomponents

Helpers

Static content

Types

Avoid semicolons and extra braces

Prefer early return and one-liner logic where possible

‚ö†Ô∏è Error Handling & Validation

Use guard clauses for errors and edge cases

Keep "happy path" at the bottom of the function

Validate inputs with Zod

Throw custom errors (AuthError, ValidationError) as needed

Return clean, user-friendly error messages

Never expose internal logic to client

Log errors on the server only

üîê Authentication & Sessions

Auth system:

Email/password

bcrypt for hashing

JWT for session tokens (stored in HTTP-only cookies)

Store active sessions in a Session table

Middleware for protected routes (e.g., /dashboard)

Use next-safe-action for secure server actions with input validation

‚öôÔ∏è React & Next.js

Use React Server Components where possible

All components are functional (use function syntax)

Structure UI by domain (features/inventory, features/shift, etc.)

Use Tailwind for responsive styling and layout

Wrap async components with <Suspense fallback={...}>

Use next/image for all images (optimize with WebP, lazy loading)

Avoid useEffect unless absolutely necessary

üì¶ API & Server Logic

Backend lives in /server

Use Express routes (/api/) with separated controllers/services

Prisma for DB access (lib/db.ts)

Store logic in services (services/auth/login.ts, services/inventory/getAll.ts)

Use .env for DB credentials, JWT secrets, API keys

üóÉÔ∏è Database & Prisma

Use PostgreSQL (hosted on Supabase or Neon)

Prisma schema lives in prisma/schema.prisma

Key tables:

User, Session, InventoryItem, Order, Supplier, Shift, Notification, Transaction

Prefer enums for status fields (e.g., OrderStatus, StockLevel)

Seed development data in prisma/seed.ts

üé® UI & Components

Use Shadcn UI + Radix UI for accessibility and style

Style components using Tailwind + Class Variance Authority (CVA)

Design with atomic principles (Button, Input, etc.)

Split large components to *-view.tsx and *-logic.ts

Maintain layout hierarchy: heading > content > actions

Fully responsive design ‚Äî mobile-first approach

üß† AI Features (Phase 2+)

Use OpenAI SDK for business recommendations and summaries

Stream data using Vercel AI SDK if needed

Always sanitize inputs

Handle errors gracefully and use fallback messages

Save chat/query history to database or Vercel KV

Store AI keys and endpoints securely in .env

üß™ Testing

Unit tests: Jest for services, validators, helpers

E2E tests: Playwright for flows like login, inventory update

Tests should use local Supabase or test-specific DB

Cover edge cases, unhappy paths, validation

‚ôø Accessibility & Performance

Ensure keyboard access to all components

Use ARIA labels and roles appropriately

Tailwind color contrast must follow WCAG

Optimize performance: lazy loading, suspense, caching

Monitor Core Web Vitals (LCP, CLS, FID)

üìö Documentation & DX

Use JSDoc for all utilities and service functions

Keep README.md updated with:

Tech stack and dependencies

Local dev setup

Auth flow

Deployment guide

Document all Prisma schemas and relationships

Add comments for AI-related logic and rate limits

